import { createClient } from '@supabase/supabase-js';

// Environment variables
const SUPABASE_URL = process.env.REACT_APP_SUPABASE_URL || '';
const SUPABASE_KEY = process.env.REACT_APP_SUPABASE_ANON_KEY || '';
const WEBHOOK_URL = process.env.REACT_APP_DOCUMENT_WEBHOOK_URL || 'https://southlandroofing.app.n8n.cloud/webhook/cf37f131-2041-426d-add5-1dbb8a96640b';

// Initialize Supabase client
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

/**
 * Interface representing a document with its extracted keywords and fields
 * Used for storing and retrieving document analysis results
 */
export interface DocumentKeywords {
  /** Unique identifier (auto-generated by Supabase) */
  id?: string;
  /** Original filename of the uploaded document */
  document_name: string;
  /** Associated project identifier */
  project_id: string;
  /** Array of extracted keywords from document content */
  keywords: string[];
  /** Key-value pairs of extracted structured data fields */
  extracted_fields: Record<string, string>;
  /** User ID of the person who uploaded the document */
  uploaded_by: string;
  /** Timestamp when the document was uploaded */
  uploaded_at: Date;
}

/**
 * Upload a document to the webhook for keyword extraction and store results in database
 * 
 * @param file - The document file to upload and analyze
 * @param projectId - The project ID associated with the document
 * @param userId - The user ID who uploaded the document
 * @returns Promise with the stored document keywords and extracted fields
 * @throws Error if document upload, processing, or storage fails
 */
export const uploadDocumentForKeywordExtraction = async (
  file: File,
  projectId: string,
  userId: string
): Promise<DocumentKeywords> => {
  try {
    // Validate inputs
    if (!file) throw new Error('No file provided');
    if (!projectId) throw new Error('Project ID is required');
    if (!userId) throw new Error('User ID is required');
    
    // Log file details for debugging
    console.log('Document upload - File details:', {
      name: file.name,
      type: file.type,
      size: `${(file.size / 1024).toFixed(2)} KB`,
      lastModified: new Date(file.lastModified).toISOString()
    });
    
    // Check file size (warn if over 10MB as many services have limits)
    if (file.size > 10 * 1024 * 1024) {
      console.warn('Document upload - Large file detected:', `${(file.size / (1024 * 1024)).toFixed(2)} MB`);
    }
    
    // Create FormData for the API request
    const formData = new FormData();
    
    // IMPORTANT: The n8n webhook expects the file with the key 'document'
    // Make sure the file is the first item in the FormData
    console.log('Document upload - Adding file to FormData with key "document":', file.name);
    formData.append('document', file, file.name);
    
    // Ensure we're using the correct project ID for the document upload
    // This ensures that if the upload is associated with a different project,
    // the webhook will receive the corresponding project ID
    console.log('Document upload - Using project ID for document:', projectId);
    formData.append('projectId', projectId); // This is the ID of the project where the document was uploaded
    formData.append('userId', userId);

    console.log('Document upload - Sending request to webhook:', WEBHOOK_URL);
    
    // Send the file to the webhook for processing with timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
    
    try {
      const response = await fetch(WEBHOOK_URL, {
        method: 'POST',
        body: formData,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      console.log('Document upload - Response status:', response.status);
      
      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error');
        console.error('Document upload - Error response:', errorText);
        throw new Error(`Document processing failed (${response.status}): ${errorText}`);
      }

      // Check content type to handle different response formats
      const contentType = response.headers.get('content-type');
      console.log('Document upload - Response content type:', contentType);
      
      let data;
      
      // Handle different response formats
      if (contentType && contentType.includes('application/json')) {
        try {
          // Get the response text first to check if it's empty
          const responseText = await response.text();
          console.log('Document upload - Response text length:', responseText.length);
          
          if (!responseText || responseText.trim() === '') {
            console.warn('Document upload - Empty JSON response received');
            // Handle empty response with default data
            data = {
              keywords: ['document', 'uploaded'],
              extracted_fields: {}
            };
          } else {
            // Parse JSON response manually since we already consumed the response body
            try {
              data = JSON.parse(responseText);
              console.log('Document upload - Response data structure:', Object.keys(data));
            } catch (jsonError) {
              console.error('Document upload - JSON parse error:', jsonError);
              // Fallback for invalid JSON
              data = {
                keywords: ['document', 'uploaded', 'json_parse_error'],
                extracted_fields: { error: 'Invalid JSON response' }
              };
            }
          }
        } catch (error) {
          console.error('Document upload - Error reading response:', error);
          // Fallback for response reading error
          data = {
            keywords: ['document', 'uploaded', 'response_error'],
            extracted_fields: { error: 'Error reading response' }
          };
        }
      } else {
        // Handle text response
        try {
          const textResponse = await response.text();
          console.log('Document upload - Text response:', textResponse);
          
          if (!textResponse || textResponse.trim() === '' || textResponse.trim() === 'Ok') {
            data = {
              keywords: ['document', 'uploaded', 'successfully'],
              extracted_fields: {}
            };
            console.log('Document upload - Created default response for "Ok" text');
          } else {
            // Try to parse as JSON anyway in case the content-type header is wrong
            try {
              data = JSON.parse(textResponse);
              console.log('Document upload - Parsed text response as JSON:', Object.keys(data));
            } catch (e) {
              // If parsing fails, create a structured response from the text
              console.warn('Document upload - Could not parse text as JSON, using as-is');
              data = {
                keywords: ['document', 'uploaded', 'text_response'],
                extracted_fields: { response: textResponse }
              };
            }
          }
        } catch (error) {
          console.error('Document upload - Error reading text response:', error);
          data = {
            keywords: ['document', 'uploaded', 'text_error'],
            extracted_fields: { error: 'Error reading text response' }
          };
        }
      }
      
      // Validate response data
      if (!data.keywords || !Array.isArray(data.keywords)) {
        console.error('Document upload - Invalid response format:', data);
        throw new Error('Invalid response: missing or invalid keywords array');
      }
      
      // Prepare document record for database (for future database storage)
      /* 
      const documentKeywords: DocumentKeywords = {
        document_name: file.name,
        project_id: projectId,
        keywords: data.keywords,
        extracted_fields: data.extracted_fields || {},
        uploaded_by: userId,
        uploaded_at: new Date(),
      };
      */
      
      return data;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('Document processing timed out after 30 seconds');
      }
      throw error;
    }
  } catch (error) {
    console.error('Document processing failed:', error);
    // Enhance error message with more context
    const errorMessage = error instanceof Error 
      ? `${error.message} (File: ${file.name}, Type: ${file.type}, Size: ${(file.size / 1024).toFixed(2)} KB)` 
      : 'Unknown error during document processing';
    throw new Error(errorMessage);
  }
};

/**
 * Retrieve all document keywords and extracted fields for a specific project
 * 
 * @param projectId - The project ID to fetch document data for
 * @returns Promise with an array of document keywords objects
 * @throws Error if database query fails
 */
export const getDocumentKeywords = async (projectId: string): Promise<DocumentKeywords[]> => {
  try {
    // Validate input
    if (!projectId) {
      throw new Error('Project ID is required');
    }

    // Query the database for document keywords
    const { data, error } = await supabase
      .from('document_keywords')
      .select('*')
      .eq('project_id', projectId)
      .order('uploaded_at', { ascending: false });

    if (error) {
      throw new Error(`Failed to fetch document keywords: ${error.message}`);
    }

    return data as DocumentKeywords[] || [];
  } catch (error) {
    console.error('Document keyword retrieval failed:', error);
    throw error instanceof Error ? error : new Error('Unknown error retrieving document keywords');
  }
};
